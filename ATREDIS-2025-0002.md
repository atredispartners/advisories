# Lenovo Vantage Multiple Vulnerabilities

## Vendors

* Lenovo

## Affected Products

Lenovo Vantage:
* VantageCoreAddin < 1.0.0.199
* LenovoSystemUpdateAddinâ€‚< 1.0.24.32
* LenovoVantageService < 4.3.50.0

## Summary
Lenovo Vantage is vulnerable to multiple local privilege escalation vulnerabilities. This allows attackers with access to a local Windows machine with user privileges to escalate to SYSTEM.

For full reproduction details and information on connecting to the RPC endpoints, see our full write-up at https://www.atredis.com/blog/2025/7/7/uncovering-privilege-escalation-bugs-in-lenovo-vantage.

## Remediation/Mitigation
Customers should upgrade to the latest version of the Lenovo Vantage. Three individual components were updated as a result of this advisory and need to be validated locally (see above).

## Credit

These issues were found by Bryan Alexander of Atredis Partners

## References
* https://nvd.nist.gov/vuln/detail/CVE-2025-6230
* https://nvd.nist.gov/vuln/detail/CVE-2025-6231
* https://nvd.nist.gov/vuln/detail/CVE-2025-6232
* https://support.lenovo.com/us/en/product_security/LEN-196648
* https://www.atredis.com/blog/2025/7/7/uncovering-privilege-escalation-bugs-in-lenovo-vantage

## Report Timeline
* 2025-04-25: Atredis Partners sent an initial notification to vendor, including a draft advisory
* 2025-04-25: Lenovo acknowledges receipt of the advisory and provides an internal tracking number
* 2025-05-19: Lenovo provides an update on remediation and sets an initial patch date of 7/8/25
* 2025-06-12: Lenovo inquires about retesting and asks a follow up question on findings
* 2025-06-27: Lenovo provides CVEs and retesting information
* 2025-07-08: Lenovo releases patches and advisory
* 2025-07-09: Atredis releases public blogpost
* 2025-08-05: Atredis Partners publishes advisory ATREDIS-2025-0002

## Technical Details

### CVE-2025-6230
When processing a `DeleteTable` command, the `payload` is expected to contain an embedded JSON package containing the table name which is then purged from the database:

```csharp
using (SQLiteCommand sqliteCommand = LocalSettingsDb._dbConnection.CreateCommand())
{
	string commandText = string.Format("drop table {0}", localSetting.Component) ?? "";
	sqliteCommand.CommandText = commandText;
	sqliteCommand.ExecuteNonQuery();
}
```
Unlike the read and write functions, no attempt to sanitize the `localSetting.Component` field is performed and arbitrary values can be added to the SQL query. Further, though SQLite by default does not support stacked queries, the .NET library used (the official SQLite library) supports them.

A second instance of SQL injection exists within the `DeleteSetting` handler:

```csharp
using SQLiteCommand sQLiteCommand = _dbConnection.CreateCommand();
string commandText = $"delete from {localSetting.Component} where Key=@key and UserName=@username" ?? "";
sQLiteCommand.Parameters.Add("@key", DbType.String).Value = localSetting.Key;
sQLiteCommand.Parameters.Add("@username", DbType.String).Value = localSetting.UserName;
sQLiteCommand.CommandText = commandText;
sQLiteCommand.ExecuteNonQuery();
```

While the `key` and `username` fields are properly prepared, the `localSetting.Component` field is not sanitized or prepared leading to SQL injection.

### CVE-2025-6231
The  `Set-KeyChildren` command in the `CoreVantageService` plugin is used to update user settings in the registry found at `HKCU\SOFTWARE\Lenovo`. 

The following code handles the request and updating the registry:
```csharp
private static readonly IEnumerable<string> WhiteList = new List<string> { "HKCU\\SOFTWARE\\Lenovo" };
...
KeyList[] keyList = keyChildrenRequest.KeyList;
foreach (KeyList key in keyList)
{
	try
	{
		if (WhiteList.Any((string f) => key.Location.IndexOf(f, StringComparison.OrdinalIgnoreCase) >= 0))
		{
			KeyChild[] keyChildren = key.KeyChildren;
			foreach (KeyChild keyChild in keyChildren)
			{
				RegistryQuery.WriteValue(key.Location, keyChild.Name, keyChild.Value, view64: true,
                                                           (RegistryValueType)keyChild.Type);
			}
		}
	}
        ...
```
However, the check is only validating that the requested key _is within_ the provided location (via `IndexOf(..) >= 0`) not necessarily that it is in actuality. For example:

```
HKLM\SOFTWARE\Lenovo\HKCU\SOFTWARE\Lenovo
```

Because the whitelisted string is present in the path the write would be allowed. By leveraging writable HKLM keys and symbolic links, an unprivileged attacker could make updates to privileged HKLM entries (such as services) to escalate their privileges to admin.

### CVE-2025-6232
The `LenovoSystemUpdateAddin`, which is responsible for managing Vantage and Vantage add-in updates in addition to third-party software managed by Lenovo. This bug is a combination of two logic issues: a path traversal and a TOCTOU, which when combined lead to LPE.

One of the supported commands, `Do-DownloadAndInstallAppComponent`, is used to download and install first and third party applications within Lenovo Vantage. A sub-command provides `InstallOnly` functionality, meaning it will not download a provided package but only attempt to install it. The update manifest is validated via the following:

```csharp
string text = string.Empty;
string text2 = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
     "Lenovo\\Vantage\\AddinData\\LenovoSystemUpdateAddin\\GeneralDownload", 
     request.AppID, request.AppID + ".xml");[0] 
if (useCachedFile && File.Exists(text2))
{
	if (new XMLFileValidator().GetTrustStatus(text2).Equals(TrustStatus.FileTrusted)) [1]
	{
		text = File.ReadAllText(text2, Encoding.UTF8); [2]
	}
}
else
{
	text = DownloadApplicationDescription(request.AppID, intermediateResponseFunction, token, ref response);
}
```
There are two bugs in the above code that result in the loading of an untrusted application manifest. First, at \[0\] we can see the manifest path being created directly with `request.AppID`. This is provided by the request and is never validated or sanitized. Therefore a user can provide a malicious AppID traversing to a different directory:

```
{ "AppID", "..\\..\\..\\..\\boo2\\MLeno" }
=> C:\boo2\MLeno.xml
```

Second, at \[1\] we see the `XMLFileValidator` performing an authentication check on the XML. This leverages `Lenovo.CertificateValidation.Native.dll!ValidateXmlFile` to check the signature block. If its trusted, it then reads the XML content. Because we have modified the manifest file path to a user-controlled location and because the authentication and read operations are not atomic, we can leverage opportunistic locks to modify the contents of the XML file.

This can be exploited by unprivileged users to induce the installation of malicious or maliciously modified applications.
